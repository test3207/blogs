---
title: VSC copilot chat 上下文工程
date: 2026-02-03 13:29:26
tags:
---

> **Disclaimer**: This article is based on an internal tech sharing session. Sensitive information has been removed for confidentiality reasons.

## 例子

想先给大家演示一下几个例子，我最近为组内repo做了一些工具，包括Oncall，也包括一些PR Implementation以及PR Review。给大家展示一下整个工作流。我把整个conversation都单独写出来了，注意这些follow开头的对话，在vsc中其实是一个斜杠命令的形式输入的，这是vsc自带的这个chat agent的小trick。等下我说一些无聊的东西的时候，大家可以偷偷看一下解解闷。

我今天给大家要介绍的并不是这些工具本身，我知道可能已经有一些同事想问了，这些工具看起来好像值得一试，我能不能快速地引入我们的项目或者oncall队列中，答案很遗憾是不行的。这些tools都和我们组内repo本身非常耦合。

我今天想讲的，是一个更加general一些的topic：如何高效地构建一些tools，来帮助我们的日常工作。

## 引入

在我这里的尝试之前，其实组内repo自己本身，就已经有同事写过一些prompt，只是似乎就不是很好用。在我们jump into details之前，我想请大家回想一下两件事，第一，在没有AI介入之前，我们的开发工作流是怎样的，比如开发某一个新feature；第二，在AI介入之后，它经常出现什么问题。

第一个问题，可能大家细节上可能都因人而异，但是大体的workflow应该是：老板或者PM给你assign一个workitem，或者你自己建一个。根据WI了解一些上下文，比如上下游调用链，实现的目的。根据了解到的上下文信息，可能有design review，或者最少做之前会想想应该要怎么实现。写完了会想想，要有什么test case。测试结束了，再提交PR。对吧？

第二个问题，其实也很因人而异。我能想到的几个常见的，长对话里忘记东西，或者即使是正常长度的对话，有一些细节可能就做得似是而非，或者反复说过的东西，又很经常反复说。

我举一个非常简单的例子，你现在几乎当场可以复现的问题：它用ADO MCP，基本上不能一次性拿到你想要的pull request，它一定会尝试基础的pr工具，但是输入的是repo名字，然后报错需要org名字，而org名字又不在tool的参数里，它就说mcp tool有问题，然后它会用另一个list的tool，才能拿到pr。

刚才请大家思考两个问题，就是为了引出大家熟知的上下文：context的概念。

## vsc copilot chat 上下文简介

今天的分享不会引入agent本身的一些概念，我仅针对vsc copilot chat这一agent做一些介绍。注意我后面提到的所有名词，包括instruction，prompt，都是特指的这个agent的概念，而不是general口头交流的概念。

大家应该或多或少了解一些，我们使用的models都有一些context大小的限制，这里给大家展示一下大致的大小，可以打开选择model，就能看到各种模型的context上限了。简单来说，就是一次会话中它能记住的东西。而这个空间是比较有限的，当达到限制后，要么向早期的chatgpt一样，直接不让继续对话，要么触发summary，会把context的内容有选择性地压缩之后，带入新一轮的对话。这引出了一个关键的话题：除了任务本身所需之外，其他的context应该越小越好，这样一次对话中，model才能用更多的context更完整地执行任务。

那么哪些东西算到context，首先就是copilot instruction，以及它的引用；第二就是prompt，这里的prompt是专有名词，是vsc copilot chat这个agent的一个概念，这我稍后会讲到；再一个就是我们的对话。要注意到，触发summary之后，agent会自己决定要压缩的内容，不管是instruction，还是prompt，还是conversation。所以当你触发summary的时候，差不多就是时候停止了，总结一下关键信息，开始下一轮，否则在你不知道有没有压缩到关键信息的情况下继续开发，往往结果都不会很好。

我刚才也说了，上下文的管理其实是非常关键的事情，让model有更多处理任务的上下文空间。因此我们需要关心如何管理instruction和prompt。对话这个就是我们自由发挥的空间了，虽然我很想建议大家少说谢谢，但是我还是经常说谢谢，为了某一天AI终于占领整个地球了，会考虑到我经常对它们说谢谢而放我一马。

这些内容除了需要精简之外，还需要什么？instruction这个大家都明白，每次聊天的时候，有这么一个used reference，就是这个instruction，说明它是每次都加载的。那么这个prompt又是什么？我刚才提到，这里的prompt是vsc的一个专有术语，它和别的context没有太多不同，唯一的优势是，在vsc里面，你可以通过斜杠的方式快速引入整段context。instruction和prompt相较于对话，最大的好处是可以DRY。我刚才举的那个ADO读不了PR的例子，你确实可以不用instruction和prompt，通过对话一轮一轮引导模型，找到正确的答案。但是如果是已知解法的问题，最好的方案，那就是放在instruction或者prompt里面，你的对话无疑是要占用很多无用的思考的context的，直接规定解法才是占用context最小的方案。顺便一提，正确的解法是：提供正确的repo id，而不是repo name，才能在ado MCP tool里面工作。

那么对于instruction和prompt这两者之间，我们又应该怎么去管理？

先说说它们的核心区别。instruction是自动加载的，每次对话都会带入；prompt是手动加载的，通过斜杠命令引入。这就决定了它们的分工：instruction放通用的、每次都需要的内容，prompt放特定任务才需要的内容。

我们回到刚才的问题，日常工作流是什么？拿组内repo举例：Oncall、PR implementation、PR Review，这是三种不同的任务。但它们有共同点：都在同一个ADO，都在同一个repo。所以管理方案就清楚了——instruction放这些基础信息，prompt按任务类型分别写。

这里还有两个进阶技巧。第一，prompt可以配置使用不同的tools。比如写feature的时候，不需要Oncall platform相关的tools，就不用加载，因为过多的tools本身也会占用context。第二，即使是相同类型的任务，比如PR implementation，bugfix和feature的工作流也略有不同。这种情况下，可以在prompt里引用不同的workflow文档。通过这些方式，就能让每次对话的context占用尽可能小。

远程的也应有类似的方案，那就是关键词搜索大于全文引入。这一点我们Oncall Note现在其实做得还算不错，查询历史Note这部分，agent现在确实会优先使用搜索WIKI功能，根据关键字去找可以参考的历史Incident。

## 更进一步

到刚才这一步，基础的管理上下文的工作模式，大家都应该有所了解了。接下来我会为大家介绍如何更进一步地压缩上下文。这里我给大家介绍我的另一个repo，tool1，所做的事情和tool2略有区别，后者是一些general的tool，这个repo会更personal一些，我打算讲一下里面的otp工具和sprint工具。

otp工具是我自己用的管理自己的测试账户的工具，大家不用了解太多细节，只需要知道所有需要的功能都是跑一些node.js脚本就能完成的事情。这个我给大家看一下之前的版本：早期版本和我刚才说的一样，写一些prompt，限定工具能力，可以很好的完成任务，context也足够小。那到这里为什么不能更进一步？模型能带给我们的，是一些思考的能力，这样纯脚本的工具，我直接做成mcp server不就好了？比prompt更小的，当然是一套直接能用的mcp server了。而且考虑到我们之前说的，prompt决定tools，在我不需要的时候，根本就不用管这个server的context了。

那回到sprint这里，情况略有不同。这是一个帮助我对我每月工作进行管理的一个tool，包含了一些固定的用法，比如生成指定月份的我的work item，这些我也是从一开始，直接对话，生成prompt，最后生成了固定的脚本。还有一些额外的功能是脚本做不到的，比如我会讨论每个task的估时，或者请它帮我创建还没有来得及创建，只有一些口头信息的workitem。很多地方是需要思考和交互的。那么大家可以看到，这个prompt里面，既包含了我把sprint相关的代码进行mcp server化的tools，也包含了各种指令，以及对应的workflow的reference文档。

这就是更进一步的压缩：如果某一些流程可以固定化，不需要思考的介入，那么就应该脚本化，或者mcp server化。只保留思考的流程。

## 更进两步

以上这些相信大家应该有一些基本的了解了，我在做什么事，为什么这么做。那我们工作过程中肯定有各种工作流，我应该怎么开发管理这些tools呢？一个个手搓？还是说再借助AI？

接下来为大家介绍的是tool-dev工具。那相信大家不难理解到，创建工具，本身也可以作为一个工作流来考虑。我只需要好好维护创建工具这一个工作流，剩下的我只提需求不就好了？这就是我这里介绍的tool-dev工具。

那我请大家刚才思考的第一个问题：我们日常开发的工作流应该包括哪些，再套用到这里就非常的合适了：你需要创建什么工具？有什么目的和限制？怎么设计出入参？怎么测试验收：都在这里。我们开发作为人，有一些可以选择的偏好的设计工作流，我不确定是不是最好的，但是是最explainable的。当然大家如果有更好的工作流，或者有可以改善的地方，我相信也是很有可能的，那就请大家自己探索了。

## 更进三步

分享完上述内容，我相信大家应该可以根据自己的工作内容，制作一些适用于自己或者自己团队的一些工具了。这整套流程在M1/M2 level是很实用的：投入不大，收益明确，而且门槛不高——不需要什么特殊的权限或者基础设施，有一个repo就能开始。问题仅在于，它仍然是因repo/workflow而定的，而且即使有AI的帮助，这样对话的形式，实际上需要的人工投入仍然是线性的，只是系数小一些。

再往后看一步，我理想中的形态是这样的：VS Code Copilot Chat作为入口，加上自建的专用agent协作。人只需要参与两件事——提需求和确认设计。剩下的实现、测试、验收，都交给自建agent自动完成。相比现在这样一轮一轮对话的形式，人工介入会更少，效率会更高。

## 总结

最后总结三句话：

1. 上下文是有限的，要精简——instruction放通用内容，prompt按任务分
2. 确定性流程脚本化或MCP化，只保留需要思考的部分给模型
3. 工具开发本身也是一个可以工程化的流程，用tool-dev来管理

希望今天的分享能帮助大家在日常工作中提升效率。谢谢大家！
